import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib as mpl

from . import utils
from .utils import lock_to_movement

def configure_mpl():
    '''Configures global matplotlib settings to better defaults

    sns.set_style('whitegrid')
    mpl.rcParams['font.size'] = 20
    mpl.rcParams['axes.titlesize'] = 'medium'
    mpl.rcParams['axes.labelsize'] = 'medium'
    mpl.rcParams['xtick.labelsize'] = 'medium'
    mpl.rcParams['ytick.labelsize'] = 'medium'
    mpl.rcParams['legend.fontsize'] = 'medium'
    mpl.rcParams['figure.titlesize'] = 'medium'
    mpl.rcParams['figure.figsize'] = (8, 6)
    mpl.rcParams['axes.spines.right'] = False
    mpl.rcParams['axes.spines.top'] = False
    mpl.rcParams['axes.edgecolor'] = 'k'
    mpl.rcParams['svg.fonttype'] = 'none'
    '''
    sns.set_style('whitegrid')
    mpl.rcParams['font.size'] = 20
    mpl.rcParams['axes.titlesize'] = 'medium'
    mpl.rcParams['axes.labelsize'] = 'medium'
    mpl.rcParams['xtick.labelsize'] = 'medium'
    mpl.rcParams['ytick.labelsize'] = 'medium'
    mpl.rcParams['legend.fontsize'] = 'medium'
    mpl.rcParams['figure.titlesize'] = 'medium'
    mpl.rcParams['figure.figsize'] = (8, 6)
    mpl.rcParams['axes.spines.right'] = False
    mpl.rcParams['axes.spines.top'] = False
    mpl.rcParams['axes.edgecolor'] = 'k'
    mpl.rcParams['svg.fonttype'] = 'none'

def strip_ytick_labs():
    yt = plt.yticks()[0]
    plt.yticks(yt, [''] * len(yt))

def setup_ddm_plot(model, ax=None,
                   time_range=None, threshold=None):
    if ax is None:
        fig, ax = plt.subplots()
    else:
        plt.sca(ax)
    if time_range is None:
        plt.xlim(0, model.max_time)
    else:
        plt.xlim(time_range[0], time_range[1])
    ax.spines['bottom'].set_visible(False)
    if threshold is None:
        try:
            threshold = model.par_dict['a']
        except KeyError:
            raise Exception('No threshold provided, and no `a` parameter in model.')
    yl = threshold * 1.1
    plt.ylim(-yl, yl)
    plt.hlines([-threshold, threshold], linestyle='dashed', *plt.xlim())
    plt.hlines(0, *plt.xlim(), linestyle='dotted')
    return ax


def setup_race_plot(model, ax=None,
                   time_range=None, threshold=None):
    if ax is None:
        fig, ax = plt.subplots()
    else:
        plt.sca(ax)
    if time_range is None:
        plt.xlim(0, model.max_time)
    else:
        plt.xlim(time_range[0], time_range[1])
    ax.spines['bottom'].set_visible(False)
    if threshold is None:
        try:
            threshold = model.par_dict['a']
        except KeyError:
            raise Exception('No threshold provided, and no `a` parameter in model.')
    yl = threshold * 1.1
    plt.ylim(-.1, yl)
    plt.hlines([threshold], linestyle='dashed', *plt.xlim())
    plt.hlines(0, *plt.xlim(), linestyle='dotted')
    return ax


# def plot_single_trial_onetrace(model, pars=None):
#     if pars is None:
#         pars = model.pars
#     x, resp, rt = model._do_trial(pars)
#     t = np.arange(0, model.max_time, model.dt)
#     ax = setup_ddm_plot(model)
#     plt.plot(t, x)
#     return ax

def plot_Xs(Xs, colours = ['g', 'b'], labels=['One', 'Two']):
    for i, X in enumerate(Xs):
        for j in range(1, X.shape[0]):
            plt.plot(X.iloc[j], alpha=.5, color=colours[i], label='__none__')
        plt.plot(X.iloc[0], alpha=.5, color=colours[i], label=labels[i])
    plt.legend()
    plt.ylim(0, 1.)

def plot_X_diff(Xs):
    dX = Xs[0] - Xs[1]
    for j in range(0, dX.shape[0]):
        plt.plot(dX.iloc[j], alpha=.5, color='b')
    plt.ylim(-1, 1.)

def plot_kde(x, *args, **kwargs):
    raise NotImplementedError('fixme!')
    # bw = bw_silverman(x) # From utils?!
    # kde = stats.gaussian_kde(x, bw_method='silverman')
    # t = np.arange(0, 5000, 20)
    # plt.plot(t, kde.evaluate(t))


# Complex Visualisation Functions
def plot_trace_mean(model, X=None, n=100, ax=None, label=None):
    '''Plot mean and SD of accumulator traces.
    This function creates a basic plot, that
    should be augmented for visualising specific models.

    Args:
        model: The model object.
        X: Model simulations generated by model.do_dataset().
                 If None, simulated from the model object.
        n: Number of traces to plot/simulate.
        ax: Axis to plot to. If None, a new figure is created.

    Returns:
        ax: The figure axis.
    '''
    if X is None:
        X, _, _ = model.do_dataset(n)
    if ax is None:
        ax = plt.subplot(111)
    # pars = model.par_dict
    plt.sca(ax)
    m = X.mean()
    sd = X.std()
    t = X.columns.values.astype(float)
    plt.plot(t, m, linewidth=3, label=label)
    plt.fill_between(t, m - sd, m + sd, alpha=.3)
    return ax


def plot_traces(model, X=None, responses=None, rts=None, n=50, ax=None,
                threshold=None,
                terminate=False, show_mean=True,
                label=None, alpha=.1, color='b'):
    '''Plot mean and SD of accumulator traces.
    This function creates a basic plot, that
    should be augmented for visualising specific models.

    Args:
        model: The model object.
        X, responses, rts: Model simulations generated by model.do_dataset().
                 If None, simulated from the model object.
        n: Number of traces to plot/simulate.
        ax: Axis to plot to. If None, a new figure is created.

    Returns:
        ax: The figure axis.
    '''
    if X is None:
        X, responses, rts = model.do_dataset(n)
    else:
        X = X.copy()
    if threshold is None:
        threshold = model.par_dict['a']
    if ax is None:
        ax = plt.subplot(111)
    t = X.columns.values.astype(float)
    n = min(n, len(X))
    m = X.mean() # Calculate mean before getting rid of post-response data
    if terminate:
        for i, rt in enumerate(rts):
            X.iloc[i, t > rt] = np.nan
    for i in range(n):
        if (i==0) & (label is not None) & (show_mean==False):
            plt.plot(t, X.iloc[i], color=color, alpha=alpha, label=label)
        else:
            plt.plot(t, X.iloc[i], color=color, alpha=alpha)

    if terminate:
        plt.scatter(rts[:n], responses[:n] * threshold, color=color, alpha=.5)
    if show_mean:
        if rts is not None:
            end = rts.max()
        else:
            end = m.index[-1]
        m.loc[:end].plot(color=color, linewidth=3, ax=ax, label=label)
    return ax

def quickplot(X, n=20, times=None):
    if type(X) == pd.DataFrame:
        if times is None:
            times = X.columns
        X = X.values
    if type(times) != np.ndarray:
        times = np.array(times)
    n = min(n, X.shape[0])
    if times is None:
        times = np.linspace(0, 5, X.shape[1])
    for i in range(n):
        plt.plot(times, X[i], alpha=.2, color='b')

## Some incomplete model-specific plots

def visualise_ddm(model, model_type='ddm',
                  measure='means',
                  n=None,
                  threshold=None):
    '''Produces a full 3 panel overview of a DDM or HDDM model'''
    measures = ['means', 'raw']
    models = ['ddm', 'wald'] # More to add!
    assert(measure in measures), 'measure most be one of %s, not %s' % (repr(measures), measure)
    assert(model_type in models), 'model_type most be one of %s, not %s' % (repr(models), model_type)
    max_t = model.max_time
    if model_type == 'ddm':
        resps = [1, -1]
        setup_func = setup_ddm_plot
        bins = np.arange(-max_t, max_t, .25)
    elif model_type == 'wald':
        resps = [1]
        setup_func = setup_race_plot
        bins = np.arange(0, max_t, .25)
    else:
        raise ValueError()

    if n is None:
        n = {'means': 100, 'raw': 50}[measure]
    if threshold is None:
        for v in ['a', 'a_mu']:
            if v in model.par_dict.keys():
                threshold = model.par_dict[v]
    X, responses, rts = model.do_dataset(n=n)
    colors = ['#1f77b4', '#ff7f0e']
    fig, axes = plt.subplots(1, 3, figsize=(16, 3))
    ax0 = setup_func(model, ax=axes[0],
                     threshold=threshold,
                     time_range=(0, max_t))
    for resp, color in zip([1, -1], colors):
        mask = responses == resp
        if mask.sum() > 0:
            if measure=='means':
                plot_trace_mean(model, X[mask], ax=ax0, label='Response: %i' % resp)
            elif measure=='raw':
                plot_traces(model, X[mask], responses[mask], rts[mask], ax=ax0,
                            terminate=True, show_mean=True,
                            threshold=threshold,
                            color=color, label='Response: %i' % resp)
    plt.legend(loc='center right')
    plt.title('Stimulus-locked signals')

    plt.sca(axes[1])
    for r in resps:
        plt.hist(r * rts[responses==r] , bins=bins)
    plt.title('Response Times')

    ax2 = setup_func(model, ax=axes[2], time_range=(-1, 0), threshold=threshold)
    for resp, color in zip([1, -1], colors):
        mask = responses == resp
        if mask.sum() > 0:
            resp_mX = lock_to_movement(X[mask], rts[mask], duration=1)
            if measure=='means':
                plot_trace_mean(model, resp_mX, ax=ax2, label='Response: %i' % resp)
            elif measure=='raw':
                plot_traces(model, resp_mX, ax=ax2,
                            threshold=threshold,
                            show_mean=True,
                            color=color, label='Response: %i' % resp)
    plt.legend(loc='center right')
    plt.title('Response-locked signals')
    return fig, axes


def _plot_race_results(X1, X2, responses, rts, n=25, lines=True, means=True):
    times = np.arange(0, 5, .001)
    if lines:
        for i in range(n):
            rt = rts[i]
            if np.isnan(rt):
                rti = -1
            else:
                rti = int(rt*1000)
            for col, X in zip(['b', 'r'], [X1, X2]):
                plt.plot(times[:rti], X[i,:rti], color=col, alpha=.2)
                plt.scatter(times[rti], X[i,rti], color=col)
    if means:
        for col, X in zip(['b', 'r'], [X1, X2]):
            m, sd = X.mean(0), X.std(0)
            plt.plot(times, m, color=col)
            plt.fill_between(times, m-sd, m+sd, alpha=.2, color=col)
