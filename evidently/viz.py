import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib as mpl

from . import utils
from .utils import lock_to_movement


'''
Visualisation functions
'''

def configure_mpl():
    '''Configures global matplotlib settings to better defaults

    | sns.set_style('whitegrid')
    | mpl.rcParams['font.size'] = 20
    | mpl.rcParams['axes.titlesize'] = 'medium'
    | mpl.rcParams['axes.labelsize'] = 'medium'
    | mpl.rcParams['xtick.labelsize'] = 'medium'
    | mpl.rcParams['ytick.labelsize'] = 'medium'
    | mpl.rcParams['legend.fontsize'] = 'medium'
    | mpl.rcParams['figure.titlesize'] = 'medium'
    | mpl.rcParams['figure.figsize'] = (8, 6)
    | mpl.rcParams['axes.spines.right'] = False
    | mpl.rcParams['axes.spines.top'] = False
    | mpl.rcParams['axes.edgecolor'] = 'k'
    | mpl.rcParams['svg.fonttype'] = 'none'
    '''
    sns.set_style('whitegrid')
    mpl.rcParams['font.size'] = 20
    mpl.rcParams['axes.titlesize'] = 'medium'
    mpl.rcParams['axes.labelsize'] = 'medium'
    mpl.rcParams['xtick.labelsize'] = 'medium'
    mpl.rcParams['ytick.labelsize'] = 'medium'
    mpl.rcParams['legend.fontsize'] = 'medium'
    mpl.rcParams['figure.titlesize'] = 'medium'
    mpl.rcParams['figure.figsize'] = (8, 6)
    mpl.rcParams['axes.spines.right'] = False
    mpl.rcParams['axes.spines.top'] = False
    mpl.rcParams['axes.edgecolor'] = 'k'
    mpl.rcParams['svg.fonttype'] = 'none'

def strip_ytick_labs():
    yt = plt.yticks()[0]
    plt.yticks(yt, [''] * len(yt))

def setup_ddm_plot(model, ax=None,
                   time_range=None, threshold=None):
    '''Set up background for a two-boundary DDM plot'''
    if ax is None:
        fig, ax = plt.subplots()
    else:
        plt.sca(ax)
    if time_range is None:
        plt.xlim(0, model.max_time)
    else:
        plt.xlim(time_range[0], time_range[1])
    for side in ['top', 'bottom', 'right']:
        ax.spines[side].set_visible(False)
    if threshold is None:
        try:
            threshold = model.par_dict['a']
        except KeyError:
            raise Exception('No threshold provided, and no `a` parameter in model.')
    yl = threshold * 1.1
    plt.ylim(-yl, yl)
    plt.hlines([-threshold, threshold], linestyle='dashed', *plt.xlim())
    plt.hlines(0, *plt.xlim(), linestyle='dotted')
    return ax


def setup_race_plot(model, ax=None,
                   time_range=None, threshold=None):
    '''Set up background for a Race plot'''
    if ax is None:
        fig, ax = plt.subplots()
    else:
        plt.sca(ax)
    if time_range is None:
        plt.xlim(0, model.max_time)
    else:
        plt.xlim(time_range[0], time_range[1])
    for side in ['top', 'bottom', 'right']:
        ax.spines[side].set_visible(False)
    if threshold is None:
        try:
            threshold = model.par_dict['a']
        except KeyError:
            raise Exception('No threshold provided, and no `a` parameter in model.')
    yl = threshold * 1.1
    plt.ylim(-.1, yl)
    plt.hlines([threshold], linestyle='dashed', *plt.xlim())
    plt.hlines(0, *plt.xlim(), linestyle='dotted')
    return ax


# Complex Visualisation Functions
def plot_trace_mean(model, X=None, n=100,
                    alpha=.3, color=None,
                    ax=None, label=None):
    '''Plot mean and SD of accumulator traces.
    This function creates a basic plot, that
    should be augmented for visualising specific models.

    Args:
        model: The model object.
        X: Model simulations generated by model.do_dataset().
                 If None, simulated from the model object.
        n: Number of traces to plot/simulate.
        alpha: Passed to plt.fill_between
        ax: Axis to plot to. If None, a new figure is created.

    Returns:
        ax: The figure axis.
    '''
    if X is None:
        X, _, _ = model.do_dataset(n)
    if ax is None:
        ax = plt.subplot(111)
    # pars = model.par_dict
    plt.sca(ax)
    m = X.mean()
    sd = X.std()
    t = X.columns.values.astype(float)
    l = plt.plot(t, m, linewidth=3, label=label, color=color)
    plt.fill_between(t, m - sd, m + sd, alpha=alpha, color=l[0].get_color())
    return ax


def plot_traces(model, X=None, responses=None, rts=None, n=50, ax=None,
                threshold=None,
                terminate=False, show_mean=True,
                label=None, alpha=.1, color='b'):
    '''Plot mean and SD of accumulator traces.
    This function creates a basic plot, that
    should be augmented for visualising specific models.

    Args:
        model: The model object.
        X, responses, rts: Model simulations generated by model.do_dataset().
                 If None, simulated from the model object.
        n: Number of traces to plot/simulate.
        ax: Axis to plot to. If None, a new figure is created.

    Returns:
        ax: The figure axis.
    '''
    if X is None:
        X, responses, rts = model.do_dataset(n)
    else:
        X = X.copy()
    if threshold is None:
        threshold = model.par_dict['a']
    if ax is None:
        ax = plt.subplot(111)
    t = X.columns.values.astype(float)
    n = min(n, len(X))
    m = X.mean() # Calculate mean before getting rid of post-response data
    if terminate:
        for i, rt in enumerate(rts):
            X.iloc[i, t > rt] = np.nan
    for i in range(n):
        if (i==0) & (label is not None) & (show_mean==False):
            plt.plot(t, X.iloc[i], color=color, alpha=alpha, label=label)
        else:
            plt.plot(t, X.iloc[i], color=color, alpha=alpha)

    if terminate:
        plt.scatter(rts[:n], responses[:n] * threshold, color=color, alpha=.5)
    if show_mean:
        if rts is not None:
            end = rts.max()
        else:
            end = m.index[-1]
        m.loc[:end].plot(color=color, linewidth=3, ax=ax, label=label)
    return ax

def quickplot(X, n=20, times=None):
    if type(X) == pd.DataFrame:
        if times is None:
            times = X.columns
        X = X.values
    if type(times) != np.ndarray:
        times = np.array(times)
    n = min(n, X.shape[0])
    if times is None:
        times = np.linspace(0, 5, X.shape[1])
    for i in range(n):
        plt.plot(times, X[i], alpha=.2, color='b')

##  ##  ##  ##  ##  #
## High-level plots #
##  ##  ##  ##  ##  #

def visualise_model(model, model_type='ddm',
                    measure='means',
                    n=None,
                    threshold=None):
    '''Produces a full 3 panel overview of common models'''
    measures = ['means', 'raw']
    models = ['ddm', 'wald', 'race'] # More to add!
    colors = ['#1f77b4', '#ff7f0e']
    assert(measure in measures), 'measure most be one of %s, not %s' % (repr(measures), measure)
    assert(model_type in models), 'model_type most be one of %s, not %s' % (repr(models), model_type)
    max_t = model.max_time
    if model_type == 'ddm':
        resps = [1, -1]
        setup_func = setup_ddm_plot
        bins = np.arange(-max_t, max_t, .25)
    elif model_type == 'wald':
        resps = [1]
        setup_func = setup_race_plot
        bins = np.arange(0, max_t, .25)
    elif model_type == 'race':
        resps = [1, -1]
        setup_func = setup_race_plot
        bins = np.arange(-max_t, max_t, .25)
    else:
        raise ValueError()

    if n is None:
        n = {'means': 100, 'raw': 50}[measure]
    if threshold is None:
        for v in ['a', 'a_mu']:
            if v in model.par_dict.keys():
                threshold = model.par_dict[v]
    X, responses, rts = model.do_dataset(n=n)
    fig, axes = plt.subplots(1, 3, figsize=(16, 3))
    ax0 = setup_func(model, ax=axes[0],
                     threshold=threshold,
                     time_range=(0, max_t))

    if model_type == 'race':
        X1, X2 = utils.split_by_accumulator(X)
        _plot_race_results(X2.values, X1.values, responses, rts,
                           colors=colors, lines=False)
    else:
        for resp, color in zip(resps, colors):
            mask = responses == resp
            if mask.sum() > 0:
                if measure=='means':
                    plot_trace_mean(model, X[mask], ax=ax0, label='Response: %i' % resp)
                elif measure=='raw':
                    plot_traces(model, X[mask], responses[mask], rts[mask], ax=ax0,
                                terminate=True, show_mean=True,
                                threshold=threshold,
                                color=color, label='Response: %i' % resp)
    plt.legend(loc='center right')
    plt.title('Stimulus-locked signals')

    plt.sca(axes[1])
    for r in resps:
        plt.hist(r * rts[responses==r] , bins=bins)
    plt.title('Response Times')

    ax2 = setup_func(model, ax=axes[2], time_range=(-1, 0), threshold=threshold)
    for resp, color in zip([1, -1], colors):
        mask = responses == resp
        if mask.sum() > 0:
            if model_type == 'race':
                rX = {-1: X1, 1: X2}[resp].copy()
                resp_mX = lock_to_movement(rX[mask], rts[mask], duration=1)
            else:
                resp_mX = lock_to_movement(X[mask], rts[mask], duration=1)
            if measure=='means':
                plot_trace_mean(model, resp_mX, ax=ax2, label='Response: %i' % resp)
            elif measure=='raw':
                plot_traces(model, resp_mX, ax=ax2,
                            threshold=threshold,
                            show_mean=True,
                            color=color, label='Response: %i' % resp)
    plt.legend(loc='center right')
    plt.title('Response-locked signals')
    return fig, axes

##  ##  ##  ##  ##
## Old functions #
##  ##  ##  ##  ##

# def plot_single_trial_onetrace(model, pars=None):
#     if pars is None:
#         pars = model.pars
#     x, resp, rt = model._do_trial(pars)
#     t = np.arange(0, model.max_time, model.dt)
#     ax = setup_ddm_plot(model)
#     plt.plot(t, x)
#     return ax

def plot_Xs(Xs, colours = ['g', 'b'], labels=['One', 'Two']):
    for i, X in enumerate(Xs):
        for j in range(1, X.shape[0]):
            plt.plot(X.iloc[j], alpha=.5, color=colours[i], label='__none__')
        plt.plot(X.iloc[0], alpha=.5, color=colours[i], label=labels[i])
    plt.legend()
    plt.ylim(0, 1.)

def plot_X_diff(Xs):
    dX = Xs[0] - Xs[1]
    for j in range(0, dX.shape[0]):
        plt.plot(dX.iloc[j], alpha=.5, color='b')
    plt.ylim(-1, 1.)

def plot_kde(x, *args, **kwargs):
    raise NotImplementedError('fixme!')
    # bw = bw_silverman(x) # From utils?!
    # kde = stats.gaussian_kde(x, bw_method='silverman')
    # t = np.arange(0, 5000, 20)
    # plt.plot(t, kde.evaluate(t))

def _plot_race_results(X1, X2, responses, rts, n=25,
                       lines=True, means=True,
                       colors=['b', 'r']):
    times = np.arange(0, 5, .001)
    if lines:
        for i in range(n):
            rt = rts[i]
            if np.isnan(rt):
                rti = -1
            else:
                rti = int(rt*1000)
            for col, X in zip(colors, [X1, X2]):
                plt.plot(times[:rti], X[i,:rti], color=col, alpha=.2)
                plt.scatter(times[rti], X[i,rti], color=col)
    if means:
        for col, X in zip(colors, [X1, X2]):
            m, sd = X.mean(0), X.std(0)
            plt.plot(times, m, color=col)
            plt.fill_between(times, m-sd, m+sd, alpha=.2, color=col)


# # # # # # # # # # # # # # # # # # # # # # # # # # #
# Special functions for Schurger Accumulator Model  #
# # # # # # # # # # # # # # # # # # # # # # # # # # #

def setup_schurger_figure():
    fig = plt.figure(constrained_layout=True, figsize=(10, 4))
    gs0 = fig.add_gridspec(1, 2, width_ratios=[1, 1])
    gs00 = gs0[0].subgridspec(2, 1)
    for i in range(2):
        fig.add_subplot(gs00[i,0])
    fig.add_subplot(gs0[1])
    return fig, fig.get_axes()

def visualise_schurger(model, n=100, rp_duration=3):
    mt = model.max_time
    dt = model.dt
    times = np.arange(0, mt, dt)
    threshold = model.par_dict['a']
    X, responses, rts = model.do_dataset(n)
    # Start plotting
    fig, axes = setup_schurger_figure()
    # Onset-locked
    ax0 = setup_race_plot(model, threshold=threshold, ax=axes[0])
    plt.ylim(-.1, threshold*1.1)
    plt.sca(axes[0])
    plot_trace_mean(model, X, ax=ax0)
    quickplot(X, times=times, n=5)
    ax0.set_title('Accumulator')
    # RTs
    plt.sca(axes[1])
    plt.hist(rts[~np.isnan(rts)], bins=np.arange(0, mt, .5))
    plt.xlim(0, mt)
    plt.xlabel('Time (s)')
    plt.title('Response times')
    for side in ['top', 'right']:
        axes[1].spines[side].set_visible(False)
    # Response
    ax2 = setup_race_plot(model, threshold=threshold, time_range=(-rp_duration, 0), ax=axes[2])
    try:
        mX = lock_to_movement(X, rts, duration=rp_duration)
        # mX = (mX.T - mX.iloc[:, 0]).T
        plot_trace_mean(model, mX, ax=ax2)
        quickplot(mX, times=mX.columns, n=5)
    except ValueError:
        mX = None
    plt.ylim(-.1, threshold*1.1)
    ax2.set_title('Response ERP')
    ax2.set_xlabel('Time to action (s)')
    ax2.spines['left'].set_visible(False)
    ax2.spines['right'].set_visible(True)
    ax2.yaxis.tick_right()
    return fig, axes
